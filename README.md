# algorithm
Algorithm achieved through JavaScript

## Collections(集合)
- 数组: 有索引，添加删除很麻烦，要移动后面的元素
- 链表(Linked list): 没有索引，存储了后一个元素的索引，相对数组来说添加删除要方便一些
- 双向链表(Double linked list) 存储了前后元素的位置
- 栈(stacks): 关注最近的一个元素。L.I.F.O(last in -- push, first out)。可以用链表实现
- 队列(queue): First in(enqueue), first out(dequeue)

## 查找和排序
- 一个个查找是最慢的，时间度为O(n)
- 求某种算法的最坏情况，把数据分成0-8个长度，算一下用该算法查找的次数，要查找的数据在这些列表之外

- 二分查找法(binary search): 
  - 原理： 对**已排序**的数组使用二分法查找。将要查找的数字与数组中间的元素进行对比，如果查找的小，就收缩数组到中间的左边。再查找中间的元素比较，直到缩小的数组(startIdx >= stopIdx)。
  - 时间复杂度： O(log(n))

- 冒泡排序(bubble sort): 
  - 原理：从第一位开始，对相邻的元素进行比较，大小交换位置，大的在后面。**这样第一轮下来后最大的元素就在数组的末尾了**。然后又重复上面的对比，这样第二大的就在倒数第二位，如此循环...
  - 复杂度： 一共要查找 n - 1轮，每轮查找 n - 1次，因此是(n-1)^2, 时间复杂度简化为 O(n^2); 由于只是交换元素位置，因此空间复杂度为O(1)

- 归并排序(merge sort):
  - 原理： 
    1️⃣ 将数组分成1， 2两个元素的几个新数组，分别对两个元素进行排序；
    2️⃣ 将相邻的两个数组合并，用第一个数组的第一位和第二个数组的第二位进行比较，写入新的合并的数组；
    3️⃣ 重复2️⃣的操作，一直合并，直到合并结束。
  - 复杂度：
    时间复杂度:一个数组要比较 n - 1次，以供要比较logn轮，为：O(nlogn)
    空间复杂度: 要新建数组，O(n)
